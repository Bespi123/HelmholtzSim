import numpy as np
from multiprocessing import Pool, cpu_count
from tqdm.notebook import tqdm

# Define global constants
MU_0 = 4 * np.pi * 1e-7  # Permeability of free space

# Coil parameters definition
class CoilParameters:
    def __init__(self, length, height, turns):
        self.L = np.array(length)   # Helmholtz testbed-length side
        self.a = self.L / 2         # Half Helmholtz testbed length side
        self.h = np.array(height)   # Separation among Helmholtz coils
        self.N = np.array(turns)    # Number of turns in Helmholtz coils

# Program functions
def generate_range(a, grid_number):
    """
    Generates a sorted NumPy array of values ranging from -2*a to 2*a with a specified step size.
    Includes critical points -2*a, 0, and 2*a.
    """
    range_vals = np.arange(-2 * a, 2 * a, grid_number)
    critical_vals = np.array([-2 * a, 0, 2 * a])
    return np.unique(np.concatenate((range_vals, critical_vals)))

def square_spires(A, h, a, num_seg):
    """
    Generates coordinates of two square coils in 3D space.
    """
    h_half = h / 2
    L_half = a
    y_coords = np.linspace(L_half, -L_half, num_seg)
    z_coords = np.linspace(-L_half, L_half, num_seg)

    sides = np.array([
        [h_half * np.ones(num_seg), y_coords, L_half * np.ones(num_seg)],  # Side 1
        [h_half * np.ones(num_seg), -L_half * np.ones(num_seg), y_coords], # Side 2
        [h_half * np.ones(num_seg), z_coords, -L_half * np.ones(num_seg)], # Side 3
        [h_half * np.ones(num_seg), L_half * np.ones(num_seg), z_coords]   # Side 4
    ])

    spire1 = np.einsum('ij,ljk->lik', A, sides)
    displacement = np.array([h, 0, 0]).reshape(3, 1)
    spire2 = np.einsum('ij,ljk->lik', A, sides - displacement[None, :, :])

    return spire1, spire2

def calculate_field(args):
    """
    Calculates the magnetic field contribution of a segment using Biot-Savart law.
    """
    A1, P, side = args
    B = np.zeros(3)
    dl = np.diff(side, axis=2)  # Differential length element for the segment

    for k in range(side.shape[0]):
        for j in range(dl.shape[2]):
            R = P - side[k, :, j]
            dB = (A1) * np.cross(dl[k, :, j], R) / np.linalg.norm(R)**3
            B += dB
    return B

def magnetic_field_square_coil_parallel(P, N, I, coils, n):
    """
    Computes the magnetic field at a point P due to two square coils using Biot-Savart law.

    Parameters:
        P (np.ndarray): Observation point where the magnetic field is calculated (3x1 vector).
        N (int): Number of turns in each coil.
        I (float): Current flowing through each coil.
        coils (np.ndarray): Array representing the geometry of the coils.
        n (int): Number of parallel tasks to divide computation.

    Returns:
        tuple: Total magnetic field (B), field of coil 1 (B1), and field of coil 2 (B2) as numpy arrays.
    """
    A1 = (N * MU_0 * I) / (4 * np.pi)

    with Pool(processes=cpu_count()) as pool:
        B_segments = []
        for i in range(P.shape[1]):  # Iterate over columns of P (0, 1, 2)
            args = [(A1, P[i, :], coils[j:j + n, :, :]) for j in range(0, coils.shape[0], n)]
            B_segments.append(pool.map(calculate_field, args))
        B_results = [np.sum(segments, axis=0) for segments in B_segments]

    return B_results[0], B_results[1], B_results[2]

def coil_simulation_1d_sequential(grid_number, A, coil_params, current, num_seg, parallel_coils):
    """
    Simulates the magnetic field generated by Helmholtz coils in a 1D sequential manner.

    Parameters:
        grid_number (int): Number of grid points along each axis.
        A (np.ndarray): Transformation matrix for coil orientation.
        coil_params (CoilParameters): Parameters of the Helmholtz coils (length, height, turns).
        current (float): Current flowing through the coils.
        num_seg (int): Number of segments per coil side.
        parallel_coils (int): Number of parallel computations for field calculation.

    Returns:
        dict: Magnetic field components and their norms in X-Y, Y-Z, and X-Z planes.
    """
    range_vals = generate_range(coil_params.a, grid_number)
    X, Y = np.meshgrid(range_vals, range_vals)

    coil = {
        'xy': {'X': X, 'Y': Y, 'Bx': np.nan * np.ones_like(X), 'By': np.nan * np.ones_like(Y), 'Bz': np.nan * np.ones_like(Y), 'norB': np.nan * np.ones_like(Y)},
        'yz': {'Y': X, 'Z': Y, 'Bx': np.nan * np.ones_like(X), 'By': np.nan * np.ones_like(Y), 'Bz': np.nan * np.ones_like(Y), 'norB': np.nan * np.ones_like(Y)},
        'xz': {'X': X, 'Z': Y, 'Bx': np.nan * np.ones_like(X), 'By': np.nan * np.ones_like(Y), 'Bz': np.nan * np.ones_like(Y), 'norB': np.nan * np.ones_like(Y)}
    }

    coil1, coil2 = square_spires(A, coil_params.h, coil_params.a, num_seg)
    coils = np.concatenate([coil1, coil2], axis=0)

    num_iter = len(X) ** 2
    progress_bar = tqdm(total=num_iter, desc="Simulation Progress")

    for i in range(len(X)):
        for j in range(len(Y)):
            P = np.stack([
                [X[i, j], Y[i, j], 0],    # P1 X-Y plane
                [0, X[i, j], Y[i, j]],    # P2 Y-Z plane
                [X[i, j], 0, Y[i, j]]     # P3 X-Z plane
            ], axis=0)

            B1, B2, B3 = magnetic_field_square_coil_parallel(P, coil_params.N, current, coils, parallel_coils)

            coil['xy']['Bx'][i, j], coil['xy']['By'][i, j], coil['xy']['Bz'][i, j] = B1
            coil['yz']['Bx'][i, j], coil['yz']['By'][i, j], coil['yz']['Bz'][i, j] = B2
            coil['xz']['Bx'][i, j], coil['xz']['By'][i, j], coil['xz']['Bz'][i, j] = B3

            coil['xy']['norB'][i, j], coil['yz']['norB'][i, j], coil['xz']['norB'][i, j] = np.linalg.norm(B1), np.linalg.norm(B2), np.linalg.norm(B3)

            progress_bar.update(1)

    progress_bar.close()

    return coil
